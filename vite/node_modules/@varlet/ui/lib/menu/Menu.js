"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _flip = _interopRequireDefault(require("@popperjs/core/lib/modifiers/flip"));

var _offset = _interopRequireDefault(require("@popperjs/core/lib/modifiers/offset"));

var _popperLite = require("@popperjs/core/lib/popper-lite");

var _components = require("../utils/components");

var _vue = require("vue");

var _props = require("./props");

var _elements = require("../utils/elements");

var _zIndex = require("../context/zIndex");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('menu');

function render(_ctx, _cache) {
  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    ref: "host",
    class: (0, _vue.normalizeClass)(_ctx.n()),
    onClick: _cache[3] || (_cache[3] = function () {
      return _ctx.handleClick && _ctx.handleClick(...arguments);
    }),
    onMouseenter: _cache[4] || (_cache[4] = function () {
      return _ctx.handleMouseenter && _ctx.handleMouseenter(...arguments);
    }),
    onMouseleave: _cache[5] || (_cache[5] = function () {
      return _ctx.handleMouseleave && _ctx.handleMouseleave(...arguments);
    })
  }, [(0, _vue.renderSlot)(_ctx.$slots, "default"), ((0, _vue.openBlock)(), (0, _vue.createBlock)(_vue.Teleport, {
    to: _ctx.teleport
  }, [(0, _vue.createVNode)(_vue.Transition, {
    name: _ctx.n(),
    onAfterEnter: _ctx.onOpened,
    onAfterLeave: _ctx.onClosed
  }, {
    default: (0, _vue.withCtx)(() => [(0, _vue.withDirectives)((0, _vue.createElementVNode)("div", {
      ref: "menu",
      style: (0, _vue.normalizeStyle)({
        zIndex: _ctx.zIndex
      }),
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('menu'), [_ctx.defaultStyle, _ctx.n('--menu-background-color') + " var-elevation--3"])),
      onClick: _cache[0] || (_cache[0] = (0, _vue.withModifiers)(() => {}, ["stop"])),
      onMouseenter: _cache[1] || (_cache[1] = function () {
        return _ctx.handleMenuMouseenter && _ctx.handleMenuMouseenter(...arguments);
      }),
      onMouseleave: _cache[2] || (_cache[2] = function () {
        return _ctx.handleMenuMouseleave && _ctx.handleMenuMouseleave(...arguments);
      })
    }, [(0, _vue.renderSlot)(_ctx.$slots, "menu")], 38
    /* CLASS, STYLE, HYDRATE_EVENTS */
    ), [[_vue.vShow, _ctx.show]])]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["name", "onAfterEnter", "onAfterLeave"])], 8
  /* PROPS */
  , ["to"]))], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarMenu',
  props: _props.props,

  setup(props) {
    var host = (0, _vue.ref)(null);
    var menu = (0, _vue.ref)(null);
    var show = (0, _vue.ref)(false);
    var {
      zIndex
    } = (0, _zIndex.useZIndex)(() => show.value, 1);
    var popover = null;
    var clickSelf = false;
    var enterMenu = false;
    var enterHost = false;
    var hostSize = {
      width: 0,
      height: 0
    };

    var computeHostSize = () => {
      var {
        width,
        height
      } = getComputedStyle(host.value);
      hostSize = {
        width: (0, _elements.toPxNum)(width),
        height: (0, _elements.toPxNum)(height)
      };
    };

    var handleMouseenter = () => {
      if (props.trigger !== 'hover') {
        return;
      }

      enterHost = true;
      open();
    };

    var handleMouseleave = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        if (props.trigger !== 'hover') {
          return;
        }

        enterHost = false;
        yield (0, _elements.doubleRaf)();

        if (enterMenu) {
          return;
        }

        close();
      });

      return function handleMouseleave() {
        return _ref.apply(this, arguments);
      };
    }();

    var handleMenuMouseenter = () => {
      if (props.trigger !== 'hover') {
        return;
      }

      enterMenu = true;
    };

    var handleMenuMouseleave = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* () {
        if (props.trigger !== 'hover') {
          return;
        }

        enterMenu = false;
        yield (0, _elements.doubleRaf)();

        if (enterHost) {
          return;
        }

        close();
      });

      return function handleMenuMouseleave() {
        return _ref2.apply(this, arguments);
      };
    }();

    var handleClick = () => {
      open();
      clickSelf = true;
    };

    var handleMenuClose = () => {
      if (clickSelf) {
        clickSelf = false;
        return;
      }

      show.value = false;
      (0, _components.call)(props['onUpdate:show'], false);
    };

    var getPosition = () => {
      computeHostSize();
      var offset = {
        x: (0, _elements.toPxNum)(props.offsetX),
        y: (0, _elements.toPxNum)(props.offsetY)
      };

      switch (props.placement) {
        case 'cover-top':
          return {
            placement: 'bottom',
            skidding: offset.x,
            distance: offset.y - hostSize.height
          };

        case 'cover-top-start':
          return {
            placement: 'bottom-start',
            skidding: offset.x,
            distance: offset.y - hostSize.height
          };

        case 'cover-top-end':
          return {
            placement: 'bottom-end',
            skidding: offset.x,
            distance: offset.y - hostSize.height
          };

        case 'cover-bottom':
          return {
            placement: 'top',
            skidding: offset.x,
            distance: -offset.y - hostSize.height
          };

        case 'cover-bottom-start':
          return {
            placement: 'top-start',
            skidding: offset.x,
            distance: -offset.y - hostSize.height
          };

        case 'cover-bottom-end':
          return {
            placement: 'top-end',
            skidding: offset.x,
            distance: -offset.y - hostSize.height
          };

        case 'cover-left':
          return {
            placement: 'right',
            skidding: offset.y,
            distance: offset.x - hostSize.width
          };

        case 'cover-right':
          return {
            placement: 'left',
            skidding: offset.y,
            distance: -offset.x - hostSize.width
          };

        case 'left':
        case 'left-start':
        case 'left-end':
          return {
            placement: props.placement,
            skidding: offset.y,
            distance: -offset.x
          };

        case 'top':
        case 'top-start':
        case 'top-end':
          return {
            placement: props.placement,
            skidding: offset.x,
            distance: -offset.y
          };

        case 'bottom':
        case 'bottom-start':
        case 'bottom-end':
          return {
            placement: props.placement,
            skidding: offset.x,
            distance: offset.y
          };

        case 'right':
        case 'right-start':
        case 'right-end':
          return {
            placement: props.placement,
            skidding: offset.y,
            distance: offset.x
          };
      }
    };

    var getPopperOptions = () => {
      var {
        placement,
        skidding,
        distance
      } = getPosition();
      return {
        placement,
        modifiers: [_extends({}, _flip.default, {
          enabled: show.value
        }), _extends({}, _offset.default, {
          options: {
            offset: [skidding, distance]
          }
        })]
      };
    }; // expose


    var resize = () => {
      popover.setOptions(getPopperOptions());
    }; // expose


    var open = () => {
      var {
        disabled
      } = props;

      if (disabled) {
        return;
      }

      show.value = true;
      (0, _components.call)(props['onUpdate:show'], true);
    }; // expose


    var close = () => {
      show.value = false;
      (0, _components.call)(props['onUpdate:show'], false);
    };

    (0, _vue.watch)(() => props.show, newValue => {
      show.value = newValue != null ? newValue : false;
    }, {
      immediate: true
    });
    (0, _vue.watch)(() => props.offsetX, resize);
    (0, _vue.watch)(() => props.offsetY, resize);
    (0, _vue.watch)(() => props.placement, resize);
    (0, _vue.watch)(() => show.value, newValue => {
      if (newValue) {
        resize();
        (0, _components.call)(props.onOpen);
      } else {
        (0, _components.call)(props.onClose);
      }
    });
    (0, _vue.watch)(() => props.trigger, newValue => {
      if (newValue === 'click') {
        document.addEventListener('click', handleMenuClose);
      } else {
        document.removeEventListener('click', handleMenuClose);
      }
    });
    (0, _vue.watch)(() => props.disabled, close);
    (0, _vue.onMounted)(() => {
      popover = (0, _popperLite.createPopper)(host.value, menu.value, getPopperOptions());

      if (props.trigger === 'click') {
        document.addEventListener('click', handleMenuClose);
      }
    });
    (0, _vue.onUnmounted)(() => {
      document.removeEventListener('click', handleMenuClose);
      popover.destroy();
    });
    return {
      menu,
      host,
      hostSize,
      show,
      zIndex,
      n,
      classes,
      handleClick,
      handleMenuClose,
      handleMouseenter,
      handleMouseleave,
      handleMenuMouseenter,
      handleMenuMouseleave,
      resize,
      open,
      close
    };
  }

});

exports.default = _default;