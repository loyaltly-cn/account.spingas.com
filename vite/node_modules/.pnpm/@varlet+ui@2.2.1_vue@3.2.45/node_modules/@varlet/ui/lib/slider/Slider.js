"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _vue = require("vue");

var _components = require("../utils/components");

var _provide = require("../form/provide");

var _elements = require("../utils/elements");

var _shared = require("@varlet/shared");

var _props = require("./props");

var _formDetails = _interopRequireDefault(require("../form-details"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('slider');
var Thumbs;

(function (Thumbs) {
  Thumbs["First"] = "1";
  Thumbs["Second"] = "2";
})(Thumbs || (Thumbs = {}));

var _withScopeId = n => ((0, _vue.pushScopeId)(""), n = n(), (0, _vue.popScopeId)(), n);

var _hoisted_1 = ["onTouchstart", "onTouchmove", "onTouchend", "onTouchcancel"];

function render(_ctx, _cache) {
  var _component_var_form_details = (0, _vue.resolveComponent)("var-form-details");

  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n())
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('block'), [_ctx.isDisabled, _ctx.n('--disabled')], [_ctx.errorMessage, _ctx.n('--error')])),
    ref: "sliderEl",
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.click && _ctx.click(...arguments);
    })
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('track'))
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('track-background')),
    style: (0, _vue.normalizeStyle)({
      background: _ctx.trackColor,
      height: _ctx.multiplySizeUnit(_ctx.trackHeight)
    })
  }, null, 6
  /* CLASS, STYLE */
  ), (0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('track-fill')),
    style: (0, _vue.normalizeStyle)(_ctx.getFillStyle)
  }, null, 6
  /* CLASS, STYLE */
  )], 2
  /* CLASS */
  ), ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)(_vue.Fragment, null, (0, _vue.renderList)(_ctx.thumbList, item => {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
      class: (0, _vue.normalizeClass)(_ctx.n('thumb')),
      key: item.enumValue,
      style: (0, _vue.normalizeStyle)({
        left: item.value + "%",
        zIndex: _ctx.thumbsProps[item.enumValue].active ? 1 : undefined
      }),
      onTouchstart: (0, _vue.withModifiers)($event => _ctx.start($event, item.enumValue), ["stop"]),
      onTouchmove: (0, _vue.withModifiers)($event => _ctx.move($event, item.enumValue), ["stop"]),
      onTouchend: $event => _ctx.end(item.enumValue),
      onTouchcancel: $event => _ctx.end(item.enumValue)
    }, [(0, _vue.renderSlot)(_ctx.$slots, "button", {
      currentValue: item.text
    }, () => [(0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.n('thumb-block')),
      style: (0, _vue.normalizeStyle)({
        background: _ctx.thumbColor
      })
    }, null, 6
    /* CLASS, STYLE */
    ), (0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('thumb-ripple'), [_ctx.thumbsProps[item.enumValue].active, _ctx.n('thumb-ripple--active')])),
      style: (0, _vue.normalizeStyle)({
        background: _ctx.thumbColor
      })
    }, null, 6
    /* CLASS, STYLE */
    ), (0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('thumb-label'), [_ctx.showLabel(item.enumValue), _ctx.n('thumb-label--active')])),
      style: (0, _vue.normalizeStyle)({
        background: _ctx.labelColor,
        color: _ctx.labelTextColor,
        height: _ctx.thumbSize === undefined ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 2),
        width: _ctx.thumbSize === undefined ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 2)
      })
    }, [(0, _vue.createElementVNode)("span", null, (0, _vue.toDisplayString)(item.text), 1
    /* TEXT */
    )], 6
    /* CLASS, STYLE */
    )])], 46
    /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
    , _hoisted_1);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  ), (0, _vue.createVNode)(_component_var_form_details, {
    "error-message": _ctx.errorMessage,
    class: (0, _vue.normalizeClass)(_ctx.n('form')),
    "var-slider-cover": ""
  }, null, 8
  /* PROPS */
  , ["error-message", "class"])], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarSlider',
  components: {
    VarFormDetails: _formDetails.default
  },
  props: _props.props,

  setup(props) {
    var {
      bindForm,
      form
    } = (0, _provide.useForm)();
    var {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      resetValidation
    } = (0, _components.useValidation)();

    var validate = () => v(props.rules, props.modelValue);

    var getThumbProps = () => ({
      startPosition: 0,
      currentLeft: 0,
      active: false,
      percentValue: 0
    });

    var validateWithTrigger = () => (0, _vue.nextTick)(() => vt(['onChange'], 'onChange', props.rules, props.modelValue));

    var sliderEl = (0, _vue.ref)(null);
    var maxWidth = (0, _vue.ref)(0);
    var isScroll = (0, _vue.ref)(false);
    var thumbsProps = (0, _vue.reactive)({
      [Thumbs.First]: getThumbProps(),
      [Thumbs.Second]: getThumbProps()
    });
    var scope = (0, _vue.computed)(() => (0, _shared.toNumber)(props.max) - (0, _shared.toNumber)(props.min));
    var unitWidth = (0, _vue.computed)(() => maxWidth.value / scope.value * (0, _shared.toNumber)(props.step));
    var thumbList = (0, _vue.computed)(() => {
      var {
        modelValue,
        range
      } = props;
      var list = [];

      if (range && (0, _shared.isArray)(modelValue)) {
        list = [{
          value: getValue(modelValue[0]),
          enumValue: Thumbs.First,
          text: toPrecision(modelValue[0])
        }, {
          value: getValue(modelValue[1]),
          enumValue: Thumbs.Second,
          text: toPrecision(modelValue[1])
        }];
      } else if ((0, _shared.isNumber)(modelValue)) {
        list = [{
          value: getValue(modelValue),
          enumValue: Thumbs.First,
          text: toPrecision(modelValue)
        }];
      }

      return list;
    });
    var getFillStyle = (0, _vue.computed)(() => {
      var {
        activeColor,
        range,
        modelValue
      } = props;
      var left = range && (0, _shared.isArray)(modelValue) ? getValue(Math.min(modelValue[0], modelValue[1])) : 0;
      var width = range && (0, _shared.isArray)(modelValue) ? getValue(Math.max(modelValue[0], modelValue[1])) - left : getValue(modelValue);
      return {
        width: width + "%",
        left: left + "%",
        background: activeColor
      };
    });
    var isDisabled = (0, _vue.computed)(() => props.disabled || (form == null ? void 0 : form.disabled.value));
    var isReadonly = (0, _vue.computed)(() => props.readonly || (form == null ? void 0 : form.readonly.value));

    var showLabel = type => {
      if (props.labelVisible === 'always') return true;
      if (props.labelVisible === 'never') return false;
      return thumbsProps[type].active;
    };

    var getValue = value => {
      var {
        min,
        max
      } = props;
      if (value < (0, _shared.toNumber)(min)) return 0;
      if (value > (0, _shared.toNumber)(max)) return 100;
      return (value - (0, _shared.toNumber)(min)) / scope.value * 100;
    };

    var toPrecision = value => {
      if (!(0, _shared.isNumber)(value)) return 0;
      var num = value;
      if (num < Number(props.min)) num = Number(props.min);
      if (num > Number(props.max)) num = Number(props.max);
      var isInteger = parseInt("" + num, 10) === num;
      return isInteger ? num : (0, _shared.toNumber)(num.toPrecision(5));
    };

    var setPercent = (moveDistance, type) => {
      var rangeValue = [];
      var {
        step,
        range,
        modelValue,
        onChange,
        min
      } = props;
      var stepNumber = (0, _shared.toNumber)(step);
      var roundDistance = Math.round(moveDistance / unitWidth.value);
      var curValue = roundDistance * stepNumber + (0, _shared.toNumber)(min);
      var prevValue = thumbsProps[type].percentValue * stepNumber + (0, _shared.toNumber)(min);
      thumbsProps[type].percentValue = roundDistance;

      if (range && (0, _shared.isArray)(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }

      if (prevValue !== curValue) {
        var value = range ? rangeValue.map(value => toPrecision(value)) : toPrecision(curValue);
        (0, _components.call)(onChange, value);
        (0, _components.call)(props['onUpdate:modelValue'], value);
        validateWithTrigger();
      }
    };

    var getType = offset => {
      if (!props.range) return Thumbs.First;
      var thumb1Distance = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
      var thumb2Distance = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      var offsetToThumb1 = Math.abs(offset - thumb1Distance);
      var offsetToThumb2 = Math.abs(offset - thumb2Distance);
      return offsetToThumb1 <= offsetToThumb2 ? Thumbs.First : Thumbs.Second;
    };

    var start = (event, type) => {
      if (!maxWidth.value) maxWidth.value = sliderEl.value.offsetWidth;
      if (isDisabled.value || isReadonly.value) return;
      (0, _components.call)(props.onStart);
      isScroll.value = true;
      thumbsProps[type].startPosition = event.touches[0].clientX;
    };

    var move = (event, type) => {
      if (isDisabled.value || isReadonly.value || !isScroll.value) return;
      var moveDistance = event.touches[0].clientX - thumbsProps[type].startPosition + thumbsProps[type].currentLeft;
      thumbsProps[type].active = true;
      if (moveDistance <= 0) moveDistance = 0;else if (moveDistance >= maxWidth.value) moveDistance = maxWidth.value;
      setPercent(moveDistance, type);
    };

    var end = type => {
      var {
        range,
        modelValue,
        onEnd,
        step,
        min
      } = props;
      if (isDisabled.value || isReadonly.value) return;
      var rangeValue = [];
      thumbsProps[type].currentLeft = thumbsProps[type].percentValue * unitWidth.value;
      thumbsProps[type].active = false;
      var curValue = thumbsProps[type].percentValue * (0, _shared.toNumber)(step) + (0, _shared.toNumber)(min);

      if (range && (0, _shared.isArray)(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }

      (0, _components.call)(onEnd, range ? rangeValue : curValue);
      isScroll.value = false;
    };

    var click = event => {
      if (isDisabled.value || isReadonly.value) return;
      if (event.target.closest('.var-slider__thumb')) return;
      var offset = event.clientX - (0, _elements.getLeft)(event.currentTarget);
      var type = getType(offset);
      setPercent(offset, type);
      end(type);
    };

    var stepValidator = () => {
      var stepNumber = (0, _shared.toNumber)(props.step);

      if (isNaN(stepNumber)) {
        console.warn('[Varlet] Slider: type of prop "step" should be Number');
        return false;
      }

      if (stepNumber < 0) {
        console.warn('[Varlet] Slider: "step" should be > 0');
        return false;
      }

      return true;
    };

    var valueValidator = () => {
      var {
        range,
        modelValue
      } = props;

      if (range && !(0, _shared.isArray)(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be an Array');
        return false;
      }

      if (!range && (0, _shared.isArray)(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be a Number');
        return false;
      }

      if (range && (0, _shared.isArray)(modelValue) && modelValue.length < 2) {
        console.error('[Varlet] Slider: "modelValue" should have two value');
        return false;
      }

      return true;
    };

    var setProps = function (modelValue, step) {
      if (modelValue === void 0) {
        modelValue = props.modelValue;
      }

      if (step === void 0) {
        step = (0, _shared.toNumber)(props.step);
      }

      var getPercent = value => {
        var {
          min,
          max
        } = props;
        if (value < (0, _shared.toNumber)(min)) return 0;
        if (value > (0, _shared.toNumber)(max)) return scope.value / step;
        return (value - (0, _shared.toNumber)(min)) / step;
      };

      if (props.range && (0, _shared.isArray)(modelValue)) {
        thumbsProps[Thumbs.First].percentValue = getPercent(modelValue[0]);
        thumbsProps[Thumbs.First].currentLeft = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
        thumbsProps[Thumbs.Second].percentValue = getPercent(modelValue[1]);
        thumbsProps[Thumbs.Second].currentLeft = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      } else if ((0, _shared.isNumber)(modelValue)) {
        thumbsProps[Thumbs.First].currentLeft = getPercent(modelValue) * unitWidth.value;
      }
    };

    var reset = () => {
      var resetValue = props.range ? [0, 0] : 0;
      (0, _components.call)(props['onUpdate:modelValue'], resetValue);
      resetValidation();
    };

    var sliderProvider = {
      reset,
      validate,
      resetValidation
    };
    (0, _components.call)(bindForm, sliderProvider);
    (0, _vue.watch)([() => props.modelValue, () => props.step], _ref => {
      var [modelValue, step] = _ref;
      if (!stepValidator() || !valueValidator() || isScroll.value) return;
      setProps(modelValue, (0, _shared.toNumber)(step));
    });
    (0, _vue.watch)(maxWidth, () => setProps());
    (0, _vue.onMounted)(() => {
      if (!stepValidator() || !valueValidator()) return;
      maxWidth.value = sliderEl.value.offsetWidth;
    });
    return {
      n,
      classes,
      Thumbs,
      sliderEl,
      getFillStyle,
      isDisabled,
      errorMessage,
      thumbsProps,
      thumbList,
      multiplySizeUnit: _elements.multiplySizeUnit,
      toNumber: _shared.toNumber,
      showLabel,
      start,
      move,
      end,
      click
    };
  }

});

exports.default = _default;